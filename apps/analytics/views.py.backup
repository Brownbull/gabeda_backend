from rest_framework import viewsets, status, generics, parsers
from rest_framework.decorators import action
from rest_framework.response import Response
from rest_framework.permissions import IsAuthenticated
from django.core.files.storage import default_storage
from django.core.files.base import ContentFile
from django.utils import timezone
from django.conf import settings
from apps.accounts.models import CompanyMember
from .models import (
    DataUpload, Transaction, Dataset, AnalyticsResult, CompanyConfig,
    ProcessingJob, ModelResult, DataExport
)
from .serializers import (
    DataUploadSerializer,
    CSVUploadSerializer,
    TransactionSerializer,
    DatasetSerializer,
    AnalyticsResultSerializer,
    AnalyticsResultListSerializer,
    CompanyConfigSerializer,
    ProcessingJobSerializer,
    ProcessingJobListSerializer,
    ProcessingJobCreateSerializer,
    ModelResultSerializer,
    ModelResultListSerializer,
    DataExportSerializer,
    DataExportListSerializer
)
import os


class CSVUploadView(generics.CreateAPIView):
    """
    API endpoint for uploading CSV files
    POST /api/analytics/companies/{company_id}/upload/
    """

    permission_classes = [IsAuthenticated]
    serializer_class = CSVUploadSerializer
    parser_classes = [parsers.MultiPartParser, parsers.FormParser]

    def create(self, request, *args, **kwargs):
        company_id = self.kwargs.get('company_id')

        # Check if user is a member of this company
        member = CompanyMember.objects.filter(
            company_id=company_id,
            user=request.user
        ).first()

        if not member:
            return Response(
                {'error': 'You are not a member of this company.'},
                status=status.HTTP_403_FORBIDDEN
            )

        # Validate file
        serializer = self.get_serializer(data=request.data)
        serializer.is_valid(raise_exception=True)

        uploaded_file = serializer.validated_data['file']

        # Create upload directory if it doesn't exist
        upload_dir = f'uploads/{company_id}/'
        os.makedirs(os.path.join(settings.MEDIA_ROOT, upload_dir), exist_ok=True)

        # Generate unique file name
        timestamp = timezone.now().strftime('%Y%m%d_%H%M%S')
        file_name = f"{timestamp}_{uploaded_file.name}"
        file_path = os.path.join(upload_dir, file_name)

        # Save file (default_storage already uses MEDIA_ROOT)
        full_path = default_storage.save(
            file_path,
            ContentFile(uploaded_file.read())
        )

        # Create DataUpload record
        data_upload = DataUpload.objects.create(
            company_id=company_id,
            uploaded_by=request.user,
            file_name=uploaded_file.name,
            file_size=uploaded_file.size,
            file_path=full_path,
            status='pending'
        )

        # Process immediately (synchronous for now)
        # Queue processing task (asynchronous)
        from .tasks import process_csv_upload

        # Queue Celery task (returns immediately)
        process_csv_upload.delay(str(data_upload.id))

        # Return immediately with pending status
        return Response(
            {
                'message': 'File uploaded successfully. Processing queued.',
                'upload': DataUploadSerializer(data_upload).data,
            },
            status=status.HTTP_201_CREATED
        )


class DataUploadViewSet(viewsets.ReadOnlyModelViewSet):
    """
    API endpoint for viewing data uploads
    GET /api/analytics/uploads/ - List all uploads for user's companies
    GET /api/analytics/uploads/{id}/ - Get upload details
    """

    permission_classes = [IsAuthenticated]
    serializer_class = DataUploadSerializer

    def get_queryset(self):
        """Return uploads for companies where user is a member (or all if superuser)"""
        user = self.request.user

        # Superusers/staff can see all uploads
        if user.is_staff or user.is_superuser:
            return DataUpload.objects.all().select_related('company', 'uploaded_by').order_by('-uploaded_at')

        # Regular users only see uploads for their companies
        company_ids = CompanyMember.objects.filter(
            user=user
        ).values_list('company_id', flat=True)

        return DataUpload.objects.filter(
            company_id__in=company_ids
        ).select_related('company', 'uploaded_by').order_by('-uploaded_at')

    @action(detail=False, methods=['get'])
    def by_company(self, request):
        """Get uploads filtered by company"""
        company_id = request.query_params.get('company_id')

        if not company_id:
            return Response(
                {'error': 'company_id parameter is required.'},
                status=status.HTTP_400_BAD_REQUEST
            )

        # Check if user is a member
        member = CompanyMember.objects.filter(
            company_id=company_id,
            user=request.user
        ).first()

        if not member:
            return Response(
                {'error': 'You are not a member of this company.'},
                status=status.HTTP_403_FORBIDDEN
            )

        uploads = DataUpload.objects.filter(
            company_id=company_id
        ).select_related('company', 'uploaded_by').order_by('-uploaded_at')

        serializer = self.get_serializer(uploads, many=True)
        return Response(serializer.data)


class TransactionViewSet(viewsets.ReadOnlyModelViewSet):
    """
    API endpoint for viewing transactions
    GET /api/analytics/transactions/ - List transactions
    GET /api/analytics/transactions/{id}/ - Get transaction details
    """

    permission_classes = [IsAuthenticated]
    serializer_class = TransactionSerializer

    def get_queryset(self):
        """Return transactions for companies where user is a member"""
        user = self.request.user
        company_ids = CompanyMember.objects.filter(
            user=user
        ).values_list('company_id', flat=True)

        queryset = Transaction.objects.filter(
            company_id__in=company_ids
        ).select_related('company', 'upload')

        # Filter by company if specified
        company_id = self.request.query_params.get('company_id')
        if company_id:
            queryset = queryset.filter(company_id=company_id)

        # Filter by upload if specified
        upload_id = self.request.query_params.get('upload_id')
        if upload_id:
            queryset = queryset.filter(upload_id=upload_id)

        # Filter by date range
        start_date = self.request.query_params.get('start_date')
        end_date = self.request.query_params.get('end_date')
        if start_date:
            queryset = queryset.filter(date__gte=start_date)
        if end_date:
            queryset = queryset.filter(date__lte=end_date)

        return queryset.order_by('-date', 'transaction_id')


class DatasetViewSet(viewsets.ReadOnlyModelViewSet):
    """
    API endpoint for viewing generated datasets
    GET /api/analytics/datasets/ - List datasets
    GET /api/analytics/datasets/{id}/ - Get dataset details
    """

    permission_classes = [IsAuthenticated]
    serializer_class = DatasetSerializer

    def get_queryset(self):
        """Return datasets for companies where user is a member"""
        user = self.request.user
        company_ids = CompanyMember.objects.filter(
            user=user
        ).values_list('company_id', flat=True)

        queryset = Dataset.objects.filter(
            company_id__in=company_ids
        ).select_related('company', 'upload')

        # Filter by company if specified
        company_id = self.request.query_params.get('company_id')
        if company_id:
            queryset = queryset.filter(company_id=company_id)

        # Filter by upload if specified
        upload_id = self.request.query_params.get('upload_id')
        if upload_id:
            queryset = queryset.filter(upload_id=upload_id)

        # Filter by dataset type
        dataset_type = self.request.query_params.get('dataset_type')
        if dataset_type:
            queryset = queryset.filter(dataset_type=dataset_type)

        return queryset.order_by('-created_at')


class AnalyticsResultViewSet(viewsets.ReadOnlyModelViewSet):
    """
    API endpoint for viewing analytics results
    GET /api/analytics/results/ - List all results (role-filtered)
    GET /api/analytics/results/{id}/ - Get result details
    GET /api/analytics/results/by_type/?result_type=kpi - Filter by type
    """

    permission_classes = [IsAuthenticated]

    def get_serializer_class(self):
        if self.action == 'list':
            return AnalyticsResultListSerializer
        return AnalyticsResultSerializer

    def get_queryset(self):
        """Return analytics results for companies where user is a member"""
        user = self.request.user
        company_ids = CompanyMember.objects.filter(
            user=user
        ).values_list('company_id', flat=True)

        queryset = AnalyticsResult.objects.filter(
            company_id__in=company_ids
        ).select_related('company', 'upload')

        # Filter by company if specified
        company_id = self.request.query_params.get('company_id')
        if company_id:
            queryset = queryset.filter(company_id=company_id)

        # Filter by upload if specified
        upload_id = self.request.query_params.get('upload_id')
        if upload_id:
            queryset = queryset.filter(upload_id=upload_id)

        # Filter by result type
        result_type = self.request.query_params.get('result_type')
        if result_type:
            queryset = queryset.filter(result_type=result_type)

        return queryset.order_by('-created_at')

    def list(self, request, *args, **kwargs):
        """List analytics results with role-based filtering"""
        queryset = self.filter_queryset(self.get_queryset())

        # Get user's roles for each company
        user_roles = {}
        for member in CompanyMember.objects.filter(user=request.user):
            user_roles[str(member.company_id)] = member.role

        # Filter results based on visible_to_roles
        filtered_results = []
        for result in queryset:
            company_id = str(result.company_id)
            user_role = user_roles.get(company_id)

            # If visible_to_roles is empty, visible to all
            if not result.visible_to_roles or user_role in result.visible_to_roles:
                filtered_results.append(result)

        page = self.paginate_queryset(filtered_results)
        if page is not None:
            serializer = self.get_serializer(page, many=True)
            return self.get_paginated_response(serializer.data)

        serializer = self.get_serializer(filtered_results, many=True)
        return Response(serializer.data)

    @action(detail=False, methods=['get'])
    def by_type(self, request):
        """Get analytics results grouped by type"""
        queryset = self.get_queryset()

        # Get result_type from query params
        result_type = request.query_params.get('result_type')
        if not result_type:
            return Response(
                {'error': 'result_type parameter is required.'},
                status=status.HTTP_400_BAD_REQUEST
            )

        results = queryset.filter(result_type=result_type)
        serializer = AnalyticsResultSerializer(
            results,
            many=True,
            context={'request': request}
        )

        # Filter out None values (results user doesn't have access to)
        filtered_data = [item for item in serializer.data if item is not None]

        return Response(filtered_data)


class CompanyConfigViewSet(viewsets.ModelViewSet):
    """
    API endpoint for managing company CSV configuration
    GET /api/analytics/config/ - List all configs for user's companies
    GET /api/analytics/config/{id}/ - Get config details
    POST /api/analytics/config/ - Create new config
    PUT /api/analytics/config/{id}/ - Update config
    DELETE /api/analytics/config/{id}/ - Delete config
    GET /api/analytics/config/by_company/?company_id=xxx - Get config for specific company
    """

    permission_classes = [IsAuthenticated]
    serializer_class = CompanyConfigSerializer

    def get_queryset(self):
        """Return configs for companies where user is a member"""
        user = self.request.user
        company_ids = CompanyMember.objects.filter(
            user=user
        ).values_list('company_id', flat=True)

        return CompanyConfig.objects.filter(
            company_id__in=company_ids
        ).select_related('company', 'created_by')

    def perform_create(self, serializer):
        """Set company and created_by on creation"""
        company_id = self.request.data.get('company')

        # Check if user is a member of this company
        member = CompanyMember.objects.filter(
            company_id=company_id,
            user=self.request.user
        ).first()

        if not member:
            from rest_framework.exceptions import PermissionDenied
            raise PermissionDenied('You are not a member of this company.')

        # Check if only admin/owner can create config
        if member.role not in ['admin', 'business_owner']:
            from rest_framework.exceptions import PermissionDenied
            raise PermissionDenied('Only admins and business owners can create configuration.')

        serializer.save(created_by=self.request.user)

    def perform_update(self, serializer):
        """Check permissions before update"""
        instance = self.get_object()

        # Check if user is a member
        member = CompanyMember.objects.filter(
            company=instance.company,
            user=self.request.user
        ).first()

        if not member:
            from rest_framework.exceptions import PermissionDenied
            raise PermissionDenied('You are not a member of this company.')

        # Check if only admin/owner can update config
        if member.role not in ['admin', 'business_owner']:
            from rest_framework.exceptions import PermissionDenied
            raise PermissionDenied('Only admins and business owners can update configuration.')

        serializer.save()

    def perform_destroy(self, instance):
        """Check permissions before delete"""
        # Check if user is a member
        member = CompanyMember.objects.filter(
            company=instance.company,
            user=self.request.user
        ).first()

        if not member:
            from rest_framework.exceptions import PermissionDenied
            raise PermissionDenied('You are not a member of this company.')

        # Check if only admin can delete config
        if member.role != 'admin':
            from rest_framework.exceptions import PermissionDenied
            raise PermissionDenied('Only admins can delete configuration.')

        instance.delete()

    @action(detail=False, methods=['get'])
    def by_company(self, request):
        """Get configuration for a specific company"""
        company_id = request.query_params.get('company_id')

        if not company_id:
            return Response(
                {'error': 'company_id parameter is required.'},
                status=status.HTTP_400_BAD_REQUEST
            )

        # Check if user is a member
        member = CompanyMember.objects.filter(
            company_id=company_id,
            user=request.user
        ).first()

        if not member:
            return Response(
                {'error': 'You are not a member of this company.'},
                status=status.HTTP_403_FORBIDDEN
            )

        try:
            config = CompanyConfig.objects.select_related('company', 'created_by').get(
                company_id=company_id
            )
            serializer = self.get_serializer(config)
            return Response(serializer.data)
        except CompanyConfig.DoesNotExist:
            return Response(
                {'error': 'No configuration found for this company.'},
                status=status.HTTP_404_NOT_FOUND
            )


class ProcessingJobViewSet(viewsets.ReadOnlyModelViewSet):
    """
    API endpoint for viewing processing jobs
    GET /api/analytics/jobs/ - List all jobs
    GET /api/analytics/jobs/{id}/ - Get job details
    POST /api/analytics/jobs/create/ - Start new processing job
    """

    permission_classes = [IsAuthenticated]

    def get_serializer_class(self):
        if self.action == 'list':
            return ProcessingJobListSerializer
        elif self.action == 'create_job':
            return ProcessingJobCreateSerializer
        return ProcessingJobSerializer

    def get_queryset(self):
        """Return jobs for companies where user is a member (or all if superuser)"""
        user = self.request.user

        # Superusers/staff can see all jobs
        if user.is_staff or user.is_superuser:
            queryset = ProcessingJob.objects.all().select_related('company', 'upload')
        else:
            # Regular users only see jobs for their companies
            company_ids = CompanyMember.objects.filter(
                user=user
            ).values_list('company_id', flat=True)

            queryset = ProcessingJob.objects.filter(
                company_id__in=company_ids
            ).select_related('company', 'upload')

        # Filter by company
        company_id = self.request.query_params.get('company_id')
        if company_id:
            queryset = queryset.filter(company_id=company_id)

        # Filter by upload
        upload_id = self.request.query_params.get('upload_id')
        if upload_id:
            queryset = queryset.filter(upload_id=upload_id)

        # Filter by status
        status_param = self.request.query_params.get('status')
        if status_param:
            queryset = queryset.filter(status=status_param)

        return queryset.order_by('-created_at')

    @action(detail=False, methods=['post'])
    def create_job(self, request):
        """Create a new processing job"""
        serializer = ProcessingJobCreateSerializer(data=request.data)
        serializer.is_valid(raise_exception=True)

        upload_id = serializer.validated_data['upload_id']
        models_to_execute = serializer.validated_data.get('models_to_execute', [
            'transactions', 'daily', 'daily_hour', 'weekly', 'monthly',
            'product_daily', 'product_month', 'customer_daily', 'customer_profile'
        ])

        # Get upload
        upload = DataUpload.objects.select_related('company').get(id=upload_id)

        # Check if user is a member
        member = CompanyMember.objects.filter(
            company=upload.company,
            user=request.user
        ).first()

        if not member:
            return Response(
                {'error': 'You are not a member of this company.'},
                status=status.HTTP_403_FORBIDDEN
            )

        # Create processing job
        job = ProcessingJob.objects.create(
            company=upload.company,
            upload=upload,
            models_to_execute=models_to_execute,
            status='queued'
        )

        # Queue Celery task
        from .tasks import process_pipeline
        task = process_pipeline.delay(str(job.id))
        job.celery_task_id = task.id
        job.save(update_fields=['celery_task_id'])

        return Response(
            {
                'message': 'Processing job created successfully.',
                'job': ProcessingJobSerializer(job).data
            },
            status=status.HTTP_201_CREATED
        )


class ModelResultViewSet(viewsets.ReadOnlyModelViewSet):
    """
    API endpoint for viewing model results
    GET /api/analytics/results/ - List all results
    GET /api/analytics/results/{id}/ - Get result details
    """

    permission_classes = [IsAuthenticated]

    def get_serializer_class(self):
        if self.action == 'list':
            return ModelResultListSerializer
        return ModelResultSerializer

    def get_queryset(self):
        """Return results for companies where user is a member"""
        user = self.request.user
        company_ids = CompanyMember.objects.filter(
            user=user
        ).values_list('company_id', flat=True)

        queryset = ModelResult.objects.filter(
            company_id__in=company_ids
        ).select_related('company', 'job')

        # Filter by company
        company_id = self.request.query_params.get('company_id')
        if company_id:
            queryset = queryset.filter(company_id=company_id)

        # Filter by job
        job_id = self.request.query_params.get('job_id')
        if job_id:
            queryset = queryset.filter(job_id=job_id)

        # Filter by model name
        model_name = self.request.query_params.get('model_name')
        if model_name:
            queryset = queryset.filter(model_name=model_name)

        # Filter by result type
        result_type = self.request.query_params.get('result_type')
        if result_type:
            queryset = queryset.filter(result_type=result_type)

        return queryset.order_by('-created_at')


class DataExportViewSet(viewsets.ModelViewSet):
    """
    API endpoint for managing data exports
    GET /api/analytics/exports/ - List all exports
    GET /api/analytics/exports/{id}/ - Get export details
    POST /api/analytics/exports/ - Create new export
    DELETE /api/analytics/exports/{id}/ - Delete export
    """

    permission_classes = [IsAuthenticated]

    def get_serializer_class(self):
        if self.action == 'list':
            return DataExportListSerializer
        return DataExportSerializer

    def get_queryset(self):
        """Return exports for companies where user is a member"""
        user = self.request.user
        company_ids = CompanyMember.objects.filter(
            user=user
        ).values_list('company_id', flat=True)

        queryset = DataExport.objects.filter(
            company_id__in=company_ids
        ).select_related('company', 'job', 'requested_by')

        # Filter by company
        company_id = self.request.query_params.get('company_id')
        if company_id:
            queryset = queryset.filter(company_id=company_id)

        # Filter by job
        job_id = self.request.query_params.get('job_id')
        if job_id:
            queryset = queryset.filter(job_id=job_id)

        # Filter by status
        status_param = self.request.query_params.get('status')
        if status_param:
            queryset = queryset.filter(status=status_param)

        return queryset.order_by('-created_at')

    def perform_create(self, serializer):
        """Create export and queue Celery task"""
        job_id = self.request.data.get('job')
        job = ProcessingJob.objects.select_related('company').get(id=job_id)

        # Check if user is a member
        member = CompanyMember.objects.filter(
            company=job.company,
            user=self.request.user
        ).first()

        if not member:
            from rest_framework.exceptions import PermissionDenied
            raise PermissionDenied('You are not a member of this company.')

        # Check job is complete
        if not job.is_complete:
            from rest_framework.exceptions import ValidationError
            raise ValidationError('Job must be completed before exporting.')

        # Create export
        export = serializer.save(
            company=job.company,
            requested_by=self.request.user
        )

        # Queue Celery task
        from .tasks import generate_export
        task = generate_export.delay(str(export.id))
        export.celery_task_id = task.id
        export.save(update_fields=['celery_task_id'])

    def perform_destroy(self, instance):
        """Delete export file and record"""
        # Delete file if exists
        if instance.file_path and default_storage.exists(instance.file_path):
            default_storage.delete(instance.file_path)

        instance.delete()
